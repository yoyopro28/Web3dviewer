<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mobile 3D FPS Viewer mit Himmel & Schatten</title>
  <style>
    html, body { margin: 0; padding: 0; width:100vw; height:100vh; overflow: hidden; }
    body { background: #1d1d1d; }
    canvas { display: block; touch-action: none; }
    #loadingSpinner {
      position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
      background:rgba(30,30,30,0.85); color:#3fcf8e;
      font-family:sans-serif; font-size:1em; padding:1em 2em; border-radius:12px;
      z-index:150;
    }
    #menu { 
      position: absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      background:rgba(30,30,30,0.98); color:#fff; padding:1em 2vw; border-radius:12px; text-align:center;
      font-family:sans-serif; box-shadow: 0 12px 32px rgba(0,0,0,0.35);
      z-index:100; min-width:180px; max-width:80vw; display:none;
    }
    #menu label { display:block; margin-bottom:0.5em; font-size:1em; }
    #menu input[type="range"] { width:calc(80vw - 2em); }
    #menu .slider-tip { color:#aaa; font-size:0.85em; margin-bottom:0.5em; }
    #menu input[type="checkbox"] { transform: scale(1.1); margin-right:0.4em; }
    #menu button {
      background:#3fcf8e; color:#222; border:none; padding:0.5em 1.5em; border-radius:8px;
      font-size:0.9em; margin:0.8em 0.3em 0 0.3em;
    }
    #menu button:last-child { background:#222; color:#3fcf8e; }
    @media (max-width:600px) {
      #menu { padding:0.8em 4vw; }
      #menu label { font-size:0.9em; }
      #menu button { padding:0.4em 1.2em; font-size:0.85em; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
</head>
<body>
  <div id="loadingSpinner">Lade Modell ...</div>
  <div id="menu">
    <label for="speedSlider">
      Bewegungsgeschwindigkeit: <span id="speedValue">7.5</span>
    </label>
    <input type="range" min="1" max="30" step="0.1" id="speedSlider" value="7.5">
    <div class="slider-tip">(Sprint: <span id="sprintValue">15.0</span>)</div>

    <label for="scaleSlider" style="margin-top:1em;">
      Modell-Scale: <span id="scaleValue">0.22</span>
    </label>
    <input type="range" min="0.01" max="10" step="0.01" id="scaleSlider" value="0.22">

    <label for="lookSlider" style="margin-top:1em;">
      Kamera-Sensitivität: <span id="lookValue">0.0058</span>
    </label>
    <input type="range" min="0.001" max="0.01" step="0.0001" id="lookSlider" value="0.0058">

    <label style="margin-top:1em;">
      <input type="checkbox" id="flyToggle"> Flugmodus aktivieren
    </label>

    <button id="resetPosition">Zurück</button>
    <button id="closeMenu">Schließen</button>
  </div>

  <div id="mobileControls" style="display:none;">
    <div id="joystickZone" style="position:fixed; left:10px; bottom:10px; width:110px; height:110px; z-index:50;"></div>
    <div style="position:fixed; right:12px; bottom:12px; z-index:50; display:flex; flex-direction:column; gap:10px;">
      <button id="btnUp"   style="width:44px;height:44px;border-radius:50%;background:#3fcf8e;color:#222;">↑</button>
      <button id="btnDown" style="width:44px;height:44px;border-radius:50%;background:#3fcf8e;color:#222;">↓</button>
      <button id="btnMenu" style="width:44px;height:44px;border-radius:50%;background:#222;color:#3fcf8e;">≡</button>
    </div>
  </div>

  <script type="module">
import * as THREE from 'https://esm.sh/three@0.160.0';
import { GLTFLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
import { Sky } from 'https://esm.sh/three@0.160.0/examples/jsm/objects/Sky.js';

const MODEL_URL = './model.glb';

let camera, scene, renderer, sky;
let model, groundMeshes = [];
let velocityY = 0;
let flying = false, sprinting = false;
let yaw = 0, pitch = 0;
let cameraHolder, cameraPitch;
let groundLevel = 1.6, gravity = -22;
let startPosition = new THREE.Vector3(0, groundLevel, 5);
const clock = new THREE.Clock();

let modelScale = 0.22;
let speed = { base: 7.5, sprint: 15.0 };
let touchLookFactor = 0.0058;
let joystickInput = { x: 0, y: 0, force: 0 };
let verticalInput = 0;

// UI-Elemente
const loadingSpinner = document.getElementById('loadingSpinner');
const menu           = document.getElementById('menu');
const speedSlider    = document.getElementById('speedSlider');
const speedValue     = document.getElementById('speedValue');
const sprintValue    = document.getElementById('sprintValue');
const scaleSlider    = document.getElementById('scaleSlider');
const scaleValue     = document.getElementById('scaleValue');
const lookSlider     = document.getElementById('lookSlider');
const lookValue      = document.getElementById('lookValue');
const resetBtn       = document.getElementById('resetPosition');
const closeMenuBtn   = document.getElementById('closeMenu');
const flyToggle      = document.getElementById('flyToggle');
const mobileControls = document.getElementById('mobileControls');
const btnUp          = document.getElementById('btnUp');
const btnDown        = document.getElementById('btnDown');
const btnMenu        = document.getElementById('btnMenu');

flyToggle.addEventListener('change', e => { flying = e.target.checked; });
window.addEventListener('keydown', e => { if (e.key==='Shift') sprinting = true; });
window.addEventListener('keyup',   e => { if (e.key==='Shift') sprinting = false; });

function updateSpeedUI() {
  speedValue.textContent  = speed.base.toFixed(1);
  sprintValue.textContent = speed.sprint.toFixed(1);
}
function updateScaleUI() {
  scaleValue.textContent = modelScale.toFixed(2);
}
function updateLookUI() {
  lookValue.textContent = touchLookFactor.toFixed(4);
}

speedSlider.oninput = () => {
  speed.base   = parseFloat(speedSlider.value);
  speed.sprint = speed.base * 2;
  updateSpeedUI();
};
scaleSlider.oninput = () => {
  modelScale = parseFloat(scaleSlider.value);
  if (model) model.scale.set(modelScale, modelScale, modelScale);
  updateScaleUI();
};
lookSlider.oninput = () => {
  touchLookFactor = parseFloat(lookSlider.value);
  updateLookUI();
};
resetBtn.onclick     = () => { cameraHolder.position.copy(startPosition); velocityY = 0; };
closeMenuBtn.onclick = () => { menu.style.display = 'none'; };

window.addEventListener('DOMContentLoaded', () => {
  loadingSpinner.style.display = 'block';
  startAppWithModel(MODEL_URL);
});

function startAppWithModel(url) {
  if (!scene) {
    scene = new THREE.Scene();

    // Himmel
    sky = new Sky();
    sky.scale.setScalar(450000);
    scene.add(sky);

    // Kamera & Holder
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    cameraPitch  = new THREE.Object3D();
    cameraHolder = new THREE.Object3D();
    cameraPitch.add(camera);
    cameraHolder.add(cameraPitch);
    scene.add(cameraHolder);
    cameraHolder.position.copy(startPosition);
    cameraPitch.rotation.x = pitch;
    cameraHolder.rotation.y = yaw;

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type    = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Lichter
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(0, 200, 100);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    dirLight.shadow.camera.near = 0.5;
    dirLight.shadow.camera.far  = 500;
    scene.add(dirLight);

    // Boden
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshStandardMaterial({ color: 0x555555 })
    );
    floor.rotation.x = -Math.PI/2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Sky-Shader einstellen
    const sun = new THREE.Vector3();
    const effectController = {
      turbidity: 10,
      rayleigh: 2,
      mieCoefficient: 0.005,
      mieDirectionalG: 0.8,
      elevation: 2,
      azimuth: 180,
      exposure: renderer.toneMappingExposure
    };
    function updateSun() {
      const phi   = THREE.MathUtils.degToRad(90 - effectController.elevation);
      const theta = THREE.MathUtils.degToRad(effectController.azimuth);
      sun.setFromSphericalCoords(1, phi, theta);
      sky.material.uniforms['sunPosition'].value.copy(sun);
      renderer.toneMappingExposure = effectController.exposure;
    }
    updateSun();

    // Mobile UI & Controls
    mobileControls.style.display = '';
    enableMobileControls();
    updateSpeedUI(); updateScaleUI(); updateLookUI();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  }

  // Modell laden
  new GLTFLoader().load(url, gltf => {
    loadingSpinner.style.display = 'none';
    if (model) scene.remove(model);
    groundMeshes = [];
    model = gltf.scene;
    model.scale.set(modelScale, modelScale, modelScale);
    model.traverse(child => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
        groundMeshes.push(child);
      }
    });
    scene.add(model);

    // Spawn-Position anhand Bounding-Box
    const box    = new THREE.Box3().setFromObject(model);
    const spawnX = (box.min.x + box.max.x)/2;
    const spawnZ = (box.min.z + box.max.z)/2;
    const ray    = new THREE.Raycaster(
      new THREE.Vector3(spawnX, 9999, spawnZ),
      new THREE.Vector3(0, -1, 0), 0, 20000
    );
    const hits = ray.intersectObjects(groundMeshes, false);
    let y = groundLevel;
    if (hits.length) y = hits[0].point.y + groundLevel;
    startPosition.set(spawnX, y, spawnZ);
    cameraHolder.position.copy(startPosition);
  }, undefined, err => {
    loadingSpinner.style.display = 'none';
    alert('Fehler beim Laden der Datei!');
  });
}

function enableMobileControls() {
  const jm = nipplejs.create({
    zone: document.getElementById('joystickZone'),
    mode: 'dynamic',
    color: '#3fcf8e',
    size: 80
  });
  jm.on('move', (evt, data) => {
    joystickInput.x     = data.vector.x;
    joystickInput.y     = data.vector.y;
    joystickInput.force = Math.min(data.force, 1);
  });
  jm.on('end', () => { joystickInput.x = joystickInput.y = joystickInput.force = 0; });

  btnUp.addEventListener('touchstart', e => { e.preventDefault(); verticalInput = 1; }, { passive: false });
  btnUp.addEventListener('touchend',   e => { e.preventDefault(); verticalInput = 0; }, { passive: false });
  btnDown.addEventListener('touchstart', e => { e.preventDefault(); verticalInput = -1; }, { passive: false });
  btnDown.addEventListener('touchend',   e => { e.preventDefault(); verticalInput = 0; }, { passive: false });
  btnMenu.addEventListener('touchend',   e => { e.preventDefault(); menu.style.display = 'block'; }, { passive: false });

  let cameraTouchActive = false, cameraTouchId = null, lastTouchX = 0, lastTouchY = 0;
  renderer.domElement.addEventListener('touchstart', e => {
    for (let t of e.changedTouches) {
      if (cameraTouchId===null && t.clientX > window.innerWidth/2) {
        cameraTouchId = t.identifier;
        cameraTouchActive = true;
        lastTouchX = t.clientX; lastTouchY = t.clientY;
      }
    }
  }, { passive: false });
  renderer.domElement.addEventListener('touchmove', e => {
    if (!cameraTouchActive) return;
    for (let t of e.changedTouches) {
      if (t.identifier===cameraTouchId) {
        const dx = t.clientX - lastTouchX;
        const dy = t.clientY - lastTouchY;
        yaw   -= dx * touchLookFactor;
        pitch -= dy * touchLookFactor;
        pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
        cameraHolder.rotation.y = yaw;
        cameraPitch.rotation.x = pitch;
        lastTouchX = t.clientX; lastTouchY = t.clientY;
        e.preventDefault();
      }
    }
  }, { passive: false });
  renderer.domElement.addEventListener('touchend', e => {
    for (let t of e.changedTouches) {
      if (t.identifier===cameraTouchId) cameraTouchActive = cameraTouchId = null;
    }
  }, { passive: false });
}

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  const currentSpeed = sprinting ? speed.sprint : speed.base;

  // Bewegung
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
  const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();
  const v = new THREE.Vector3();
  v.addScaledVector(dir, joystickInput.y * joystickInput.force);
  v.addScaledVector(right, joystickInput.x * joystickInput.force);
  if (v.length()>1) v.normalize();
  v.multiplyScalar(currentSpeed * delta);
  cameraHolder.position.add(v);

  // Vertikale Achse
  if (flying) {
    cameraHolder.position.y += verticalInput * currentSpeed * delta;
  } else {
    velocityY += gravity * delta;
    let nextY = cameraHolder.position.y + velocityY * delta;
    const downRay = new THREE.Raycaster(
      new THREE.Vector3(cameraHolder.position.x, cameraHolder.position.y, cameraHolder.position.z),
      new THREE.Vector3(0,-1,0), 0, 3.5
    );
    const hits = downRay.intersectObjects(groundMeshes, false);
    let surfaceY = groundLevel;
    if (hits.length) {
      surfaceY = hits[0].point.y + groundLevel;
      if (nextY <= surfaceY) { nextY = surfaceY; velocityY = 0; }
    }
    cameraHolder.position.y = nextY;
  }

  renderer.render(scene, camera);
}
  </script>
</body>
</html>
