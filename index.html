<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mobile 3D FPS Viewer</title>
  <style>
    html, body { margin: 0; padding: 0; width:100vw; height:100vh; overflow: hidden; }
    body { background: #1d1d1d; }
    canvas { display: block; touch-action: none; }
    #loadingSpinner {
      position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
      background:rgba(30,30,30,0.85); color:#3fcf8e;
      font-family:sans-serif; font-size:1.1em; padding:1.5em 3em; border-radius:18px;
      z-index:150;
    }
    #menu { 
      position: absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      background:rgba(30,30,30,0.98); color:#fff; padding:2em 3vw; border-radius:18px; text-align:center;
      font-family:sans-serif; box-shadow: 0 16px 64px rgba(0,0,0,0.35);
      z-index:100; min-width:230px; max-width:96vw; display:none;
    }
    #menu label { display:block; margin-bottom:0.7em; font-size:1.08em; }
    #menu input[type="range"] { width:90vw; }
    #menu .slider-tip { color:#aaa; font-size:0.95em; margin-bottom:0.6em; }
    #menu button {
      background:#3fcf8e; color:#222; border:none; padding:0.7em 2em; border-radius:11px;
      font-size:1em; margin-top:1.2em;
    }
    #menu button:last-child { background:#222; color:#3fcf8e; margin-left:1em;}
    #mobileControls { pointer-events:none; }
    #mobileControls * { pointer-events:auto; user-select:none; -webkit-user-select:none; }
    @media (max-width:600px) {
      #menu { padding:1em 2vw; }
      #menu label { font-size:1em; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
</head>
<body>
  <div id="loadingSpinner">Lade Modell ...</div>
  <div id="menu">
    <label for="speedSlider">Bewegungsgeschwindigkeit: <span id="speedValue">5</span></label>
    <input type="range" min="1" max="30" step="0.1" id="speedSlider" value="5">
    <div class="slider-tip">(Sprint: <span id="sprintValue">10</span>)</div>
    <label for="scaleSlider" style="margin-top:1.4em;">Modell-Scale: <span id="scaleValue">1.00</span></label>
    <input type="range" min="0.01" max="10" step="0.01" id="scaleSlider" value="1">
    <div class="slider-tip"></div>
    <button id="resetPosition">Zurück zum Start</button>
    <button id="closeMenu">Schließen</button>
  </div>
  <div id="mobileControls" style="display:none;">
    <div id="joystickZone" style="position:fixed; left:10px; bottom:10px; width:110px; height:110px; z-index:50;"></div>
    <div style="position:fixed; right:12px; bottom:12px; z-index:50; display:flex; flex-direction:column; gap:12px;">
      <button id="btnUp" style="width:48px;height:48px;border-radius:50%;background:#3fcf8e;color:#222;font-size:1.3em;">↑</button>
      <button id="btnDown" style="width:48px;height:48px;border-radius:50%;background:#3fcf8e;color:#222;font-size:1.3em;">↓</button>
      <button id="btnMenu" style="width:48px;height:48px;border-radius:50%;background:#222;color:#3fcf8e;font-size:1.08em;">≡</button>
    </div>
  </div>
 <script type="module">
import * as THREE from 'https://esm.sh/three@0.160.0';
import { GLTFLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

const MODEL_URL = './model.glb'; // Das Modell muss im gleichen Ordner liegen wie diese HTML!

let camera, scene, renderer;
let model, groundMeshes = [];
let modelScale = 1.0;
let speed = { base: 5, sprint: 10 };
let velocityY = 0, flying = true, paused = false, onGround = false;
let move = { forward: false, back: false, left: false, right: false, up: false, down: false };
let yaw = 0, pitch = 0;
let cameraHolder, cameraPitch;
let sprinting = false;
let groundLevel = 1.6, gravity = -22;
let startPosition = new THREE.Vector3(0, groundLevel, 5);
const clock = new THREE.Clock();

// UI
const loadingSpinner = document.getElementById('loadingSpinner');
const menu = document.getElementById('menu');
const speedSlider = document.getElementById('speedSlider');
const speedValue = document.getElementById('speedValue');
const sprintValue = document.getElementById('sprintValue');
const scaleSlider = document.getElementById('scaleSlider');
const scaleValue = document.getElementById('scaleValue');
const resetBtn = document.getElementById('resetPosition');
const closeMenuBtn = document.getElementById('closeMenu');
const mobileControls = document.getElementById('mobileControls');
const btnUp = document.getElementById('btnUp');
const btnDown = document.getElementById('btnDown');
const btnMenu = document.getElementById('btnMenu');
let cameraTouchActive = false, lastTouchX = 0, lastTouchY = 0, touchLookFactor = 0.0027;

window.addEventListener('DOMContentLoaded', () => {
  loadingSpinner.style.display = 'block';
  startAppWithModel(MODEL_URL);
});

function updateSpeedUI() {
  speedValue.textContent = speed.base.toFixed(1);
  sprintValue.textContent = speed.sprint.toFixed(1);
}
function updateScaleUI() {
  scaleValue.textContent = modelScale.toFixed(2);
}
speedSlider.oninput = () => {
  speed.base = parseFloat(speedSlider.value);
  speed.sprint = speed.base * 2;
  updateSpeedUI();
};
scaleSlider.oninput = () => {
  scaleModel(parseFloat(scaleSlider.value));
};
resetBtn.onclick = () => resetPosition();
closeMenuBtn.onclick = () => menu.style.display = 'none';

function scaleModel(newScale) {
  if (!model) return;
  model.scale.set(newScale, newScale, newScale);
  modelScale = newScale;
  scaleSlider.value = modelScale.toFixed(3);
  updateScaleUI();
}
function resetPosition() {
  cameraHolder.position.copy(startPosition);
  velocityY = 0;
}

function startAppWithModel(url) {
  if (!scene) {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    cameraPitch = new THREE.Object3D();
    cameraHolder = new THREE.Object3D();
    cameraPitch.add(camera);
    cameraHolder.add(cameraPitch);
    scene.add(cameraHolder);

    cameraHolder.position.copy(startPosition);
    yaw = 0; pitch = 0;
    cameraPitch.rotation.x = pitch;
    cameraHolder.rotation.y = yaw;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    document.body.appendChild(renderer.domElement);

    let floor = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshStandardMaterial({ color: 0x555555 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
    let dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(0,200,100); dirLight.castShadow=true;
    scene.add(dirLight);

    mobileControls.style.display = '';
    enableMobileControls();
    updateSpeedUI();
    updateScaleUI();
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  }
  loadingSpinner.style.display = 'block';
  new GLTFLoader().load(url, gltf => {
    loadingSpinner.style.display = 'none';
    if (model) scene.remove(model);
    model = gltf.scene;
    model.scale.set(modelScale, modelScale, modelScale);
    model.position.set(0, 0, 0);
    scene.add(model);

    groundMeshes = [];
    gltf.scene.traverse(child => {
      if (child.isMesh) groundMeshes.push(child);
    });

    let spawnX=0, spawnZ=0;
    if (model) {
      const box = new THREE.Box3().setFromObject(model);
      spawnX = (box.min.x + box.max.x) / 2;
      spawnZ = (box.min.z + box.max.z) / 2;
    }
    let rayOrigin = new THREE.Vector3(spawnX, 9999, spawnZ);
    let down = new THREE.Vector3(0, -1, 0);
    let ray = new THREE.Raycaster(rayOrigin, down, 0, 2e4);
    let hits = ray.intersectObjects(groundMeshes, false);

    let y = groundLevel;
    if (hits.length > 0) {
      y = hits[0].point.y + 1.6;
    }
    startPosition = new THREE.Vector3(spawnX, y, spawnZ);
    cameraHolder.position.copy(startPosition);
  }, undefined, err => {
    loadingSpinner.style.display = 'none';
    alert("Fehler beim Laden der Datei!");
  });
}

function enableMobileControls() {
  let joystickManager = nipplejs.create({
    zone: document.getElementById('joystickZone'),
    mode: 'static',
    position: { left: '50%', top: '50%' },
    color: '#3fcf8e', size: 80
  });

  // *** Neuer, direkter Mapping-Ansatz über data.vector ***
  joystickManager.on('move', (evt, data) => {
    const vx = data.vector ? data.vector.x : 0;
    const vy = data.vector ? data.vector.y : 0;
    const thresh = 0.2; // Schwellwert, um ungewollte Kleinstbewegungen auszublenden

    move.forward = vy < -thresh;
    move.back    = vy >  thresh;
    move.left    = vx < -thresh;
    move.right   = vx >  thresh;
  });

  joystickManager.on('end', () => {
    move.forward = move.back = move.left = move.right = false;
  });

  // … btnUp/btnDown/btnMenu bleiben unverändert …

  renderer.domElement.addEventListener('touchstart', function(e) {
    if (e.touches.length === 1 && e.touches[0].clientX > window.innerWidth/2) {
      cameraTouchActive = true;
      lastTouchX = e.touches[0].clientX;
      lastTouchY = e.touches[0].clientY;
    }
  }, { passive: false });

  // *** Invertierte Touch-Kamera-Steuerung ***
  renderer.domElement.addEventListener('touchmove', function(e) {
    if (!cameraTouchActive) return;
    if (e.touches.length === 1) {
      const dx = e.touches[0].clientX - lastTouchX;
      const dy = e.touches[0].clientY - lastTouchY;
      // invertiere beide Achsen
      yaw   -= dx * touchLookFactor;
      pitch -= dy * touchLookFactor;
      pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
      cameraHolder.rotation.y = yaw;
      cameraPitch.rotation.x  = pitch;
      lastTouchX = e.touches[0].clientX;
      lastTouchY = e.touches[0].clientY;
      e.preventDefault();
    }
  }, { passive: false });

  renderer.domElement.addEventListener('touchend', function(e) {
    cameraTouchActive = false;
  }, { passive: false });
}


function animate() {
  requestAnimationFrame(animate);
  if (!renderer || !camera) return;
  if (!paused) {
    const delta = clock.getDelta();
    let currentSpeed = sprinting ? speed.sprint : speed.base;
    let velocity = new THREE.Vector3();

    // Bewegungsrichtung entlang Blickrichtung!
    let dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    dir.y = 0;
    dir.normalize();
    let right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();

    if (move.forward) velocity.add(dir);
    if (move.back) velocity.addScaledVector(dir, -1);
    if (move.left) velocity.addScaledVector(right, -1);
    if (move.right) velocity.add(right);
    velocity.normalize();
    velocity.multiplyScalar(currentSpeed * delta);

    cameraHolder.position.add(velocity);

    // Vertikale Bewegung (Fliegen)
    if (move.up) cameraHolder.position.y += currentSpeed * delta;
    if (move.down) cameraHolder.position.y -= currentSpeed * delta;

    // Gravity und Boden
    if (!flying) {
      velocityY += gravity * delta;
      let nextY = cameraHolder.position.y + velocityY * delta;
      let downRay = new THREE.Raycaster(
        new THREE.Vector3(cameraHolder.position.x, cameraHolder.position.y, cameraHolder.position.z),
        new THREE.Vector3(0, -1, 0), 0, 3.5
      );
      let groundHits = downRay.intersectObjects(groundMeshes, false);
      let surfaceY = groundLevel;
      if (groundHits.length > 0) {
        surfaceY = groundHits[0].point.y + 1.6;
        if (nextY <= surfaceY) {
          nextY = surfaceY;
          velocityY = 0;
          onGround = true;
        } else {
          onGround = false;
        }
      }
      cameraHolder.position.y = nextY;
    }
  }
  renderer.render(scene, camera);
}
</script>

</body>
</html>
